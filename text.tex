\documentclass[10pt,a4paper,notitlepage]{report}
\usepackage[utf8]{inputenc}
\usepackage[czech]{babel}
\usepackage[T1]{fontenc}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{float}
\usepackage{makeidx}
\usepackage{graphicx}
\usepackage{syntax}    % texlive-mdwtools
\usepackage{glossaries}
\usepackage{todonotes} % command \todo
\usepackage{hyperref}
\usepackage{listings}
\usepackage[detect-all]{siunitx} % numrange
\usepackage[
   backend=biber      % if we want unicode 
  ,style=iso-numeric % or iso-numeric for numeric citation method          
  ,babel=other        % to support multiple languages in bibliography
  ,sortlocale=cs_CZ   % locale of main language, it is for sorting
  ,bibencoding=UTF8   % this is necessary only if bibliography file is in different encoding than main document
]{biblatex}

\floatstyle{boxed}
\restylefloat{figure}
\addbibresource{literature.bib}

\author{Jan Tušil <410062@mail.muni.cz>}
\title{LLVM PO}

\newtheorem{definition}{Definice}
\newtheorem{decision}{Rozhodnutí}
\newcommand{\tuple}[1]{\langle #1 \rangle}
\newcommand{\suchthat}{\mid}

\begin{document}

\chapter{Úvod}
\section{Motivace}
Exploze stavového prostoru při model checkingu, Partial Order Redukce to řeší,
LLVM model checking je super a chceme tam POR.

To, co chceme, je vygenerovaný NTS, který není paralelní. Tedy výstupem redukce
není explicitní stavový prostor.

\section{Přístup}
Cílem této práce tedy je vytvořit ze vstupního programu v jazyce LLVM IR, jež využívá posixová vlákna, odpovídající sekvenční přechodový systém v jazyce NTS. Tuto úlohu je možné přirozeně rozdělit na dvě části, a to na
\begin{enumerate}
\item přirozený překlad programu z LLVM IR do NTS se zachováním paralelismu (část dále označovaná jako překlad), a
\item převod paralelního programu v jazyce NTS na sekvenční program (část dále označovaná jako sekvencializace).
\end{enumerate}

Tyto dvě části jsou poměrně nezávislé a mohou být implementovány jako rozdílné nástroje, pracující nad společnou knihovnou. Rozdělením navíc získáváme možnost ověřovat vlastnosti sekvenčních programů v jazyce LLVM IR nástrojem, který rozumí jazyku NTS \todo{Až na uvedená rozšíření. Nechtěli jsme mít možnost použít unbounded integery?}.

%Velký obraz - jak se vypořádat s funkčními voláními? Jaké jsem měl možnosti?

%Výsledkem trojice: llvm2nts, inliner, vlastní POR. Všechno pracuje nad knihovnou pro paměťovou
%reprezentaci NTS. Related work: Petrův parser.

%Všechno ve formě knihovny - jednoduché rozhraní, snadno použitelné.

%BTW: NTS je 'ten' - system
\subsection{Funkční volání}

Chceme tedy z paralelního NTS, který vznikl překladem z LLVM IR, učinit sekvenční. Pokud o vstupním paralelním NTS nebudeme nic předpokládat, nástroj pro sekvencializaci bude muset umět korektně zacházet s funkčními voláními, protože ta mohou být součástí NTS. To zejména znamená, že nástroj si bude muset pro každý stav výstupního systému udržovat přehled o tom, jaké funkce jsou v jakém vlákně aktivní. Implementace takového nástroje nemusí být snadná, proto jsme učinili následující rozhodnutí:

% tohle bych chtel v sedem ramecku, podobne jako byvaji citace nebo theoremy
\begin{decision}
Nástroj pro sekvencializaci předpokládá, že vstupní paralelní systém neobsahuje funkční volání, tedy (v termínech) NTS není hierarchický. Takové NTS budeme dále označovat jako "ploché".
\end{decision}

Většina skutečných programů v jazyce LLVM IR ovšem obsahují funkční volání, a rádi bychom takové programy podporovali. Nabízejí se dvě možnosti, jak takovou podporu zajistit. První spočívá v tom, že paralelní program v jazyce LLVM IR přeložíme na paralelní a (potenciálně) hierarchický přechodový systém v jazyce NTS, který následně převedeme na ekvivalentní paralelní plochý přechodový systém. Alternativní možností je nejprve odstranit funkční volání z paralelního LLVM IR programu a následně tento plochý program převést na plochý paralelní přechodový systém.

Tak či onak, programy s rekurzivním voláním nebudou podporovány.

\paragraph{Zplošťování LLVM}
Zploštění programu v LLVM IR nevyžaduje téměř žádnou další práci, protože již na tuto úlohu existuje llvm průchod. Jmenuje se
\href{http://llvm.org/docs/Passes.html#inline-function-integration-inlining}
{inline} a je součástí projektu LLVM. Nicméně nástroj pro překlad LLVM IR na NTS musí umět korektně přeložit volání funkce
\href{http://man7.org/linux/man-pages/man3/pthread\_create.3.html}
{pthread\_create(3)}, které v tomto případě nemůže být přeloženo jako volání BasicNts na úrovni NTS. Volání této funkce by tedy muselo být vhodně přeloženo již na úrovni LLVM kódu.

\paragraph{Zplošťování NTS}
Přestože je pro zplošťování NTS potřeba udělat o něco více práce, napsání odpovídajícího nástroje nám může umožnit sekvencializaci libovolného NTS. Navíc nejsme omezeni na práci s plochými NTS jako v předchozím případě. Z uvedených důvodů tato práce využívá tento přístup.

\subsection{Architektura}
Celý problém se tedy rozpadá na několik částí. Nejprve potřebujeme přeložit program z jazyka LLVM IR do formalizmu NTS, poté z přeloženého programu odstranit volání subsystémů, plochý program sekvencializovat s využitím partial order redukce a nakonec ho uložit do souboru. Pro spolupráci těchto částí je třeba mít vybudovanou vhodnou paměťovou reprezentaci programu v jazyce NTS. Existence parseru by byla užitečná (zejména pro testování), ale není nutná.

\section{Popis následujících kapitol}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Použité technologie}
\section{LLVM}
Projekt LLVM~\cite{LLVM} je sada knihoven a nástrojů, tvořící infrastrukturu pro tvorbu překladačů. Ke své činnosti využívá mezijazyk známý jako LLVM intermediate representation~\cite{LLVM-langRef} (dále LLVM IR nebo jen IR) a sadu dobře definovaných softwarových rozhraní pro manipulaci s~ním. Práci překladače vybudovaného nad LLVM lze rozdělit do několika fází: nejprve je zpracován kód ve vstupním jazyce (proběhne lexikální, syntaktická a sémantická analýza), poté je vygenerován mezikód v~jazyce LLVM IR, nad tímto pak proběhnou zvolené optimalizace, z~výsledného IR kódu je vygenerován platformově specifický kód a~proběhne linkování. Tato architektura umožňuje využít při tvorbě překladače již jednou napsaných částí~\cite{AOSABOOK-LLVM}.

\subsection{LLVM IR}
LLVM IR je typovaný jazyk podobný jazyku symbolických adres, od kterého se však liší v několika zásadních vlastnostech.
\begin{itemize}
\item LLVM IR je platformově nezávislý a není určený pro žádný fyzicky existující procesor.
\item V jazyce LLVM IR je možné používat neomezené množství registrů.
\item Do každého registru je možné přiřadit hodnotu pouze jednou. Tato vlastnost je nazývána \textit{static single assignment form} (dále \textit{SSA}).
\end{itemize}
Kód je uchováván v~modulech a~rozčleněn do funkcí, které se skládají ze základních bloků. Základní blok (basic block, dále blok) je taková posloupnost instrukcí, která má jeden vstupní bod a~jeden výstupní. Zejména tedy není možné provádět skoky dovnitř bloku nebo vyskočit z~bloku jinde, než na konci. Sémantika tohoto jazyka je dobře zdokumentována, navíc probíhá práce na její formalizaci~\cite{LLVMForm}.

\subsubsection{Instrukční sada}
Instrukční sada LLVM IR je svou jednoduchostí podobná RISCovým instrukčním sadám. Instrukce jsou rozděleny na ukončovací, binární, bitové, paměťové a ostatní, přičemž pouze ukončovací instrukce mohou měnit tok řízení. Tyto instrukce vždy ukončují Basic Block a rozhodují, který blok bude vykonán po dokončení aktuálního.

\subsubsection{Příklad}
Obrázek \ref{IR-EX} zobrazuje funkci, vygenerovanou nástrojem clang~\cite{clang} z~kódu v~jazyce C. Funkce je globálním symbolem (globální symboly mají prefix \texttt{@}), má návratovou hodnotu \texttt{i32} (dvaatřicetibitové celé číslo) a~jako parametr přijímá proměnnou téhož typu. V~těle funkce se vyskytuje pouze jedna ukončovací instrukce, totiž \texttt{ret}, a~celá funkce je tak tvořena jedním basic blockem. Symbol \texttt{\%1} označuje výsledek instrukce \texttt{alloca}, což je lokální proměnná typu ukazatel na \texttt{i32} (lokální symboly mají prefix \texttt{\%}). Následuje instrukce \texttt{store}, která zkopíruje hodnotu parametru \texttt{\%x} na právě alokované paměťové místo a~nevrací žádnou hodnotu. Po načtení hodnoty z~paměti a~přičtení jedničky je vrácen výsledek poslední operace.


\begin{figure}[h!]
\begin{lstlisting}
define i32 @add(i32 %x) #0 {
%1 = alloca i32, align 4
store i32 %x, i32* %1, align 4
%2 = load i32* %1, align 4
%3 = add nsw i32 1, %2
ret i32 %3
}
\end{lstlisting}
\caption{Ukázka IR kódu}
\label{IR-EX}
\end{figure}

\subsection{Průchody}
Průchod (orig. pass) je softwarový modul, který pracuje nad kódem v~LLVM IR. Průchody se dají rozdělit na analytické a transformační: analytické kód nijak nemodifikují, ale počítají nějakou užitečnou informaci; transformační ze vstupního kódu generují jiný. Typickým příkladem transformačního průchodu je eliminace mrtvého kódu (dead code elimination, DCE). Nástroj využívající LLVM si může zvolit, které průchody budou spuštěny; také je možné spouštět je ručně pomocí nástroje opt, dodávaného spolu s~LLVM.

\subsection{Využití}
V současné době existují nástroje pro software model checking (model checkery), které přijímají model v~jazyce LLVM IR. Mezi ně patří například Divine~\cite{BBH+13}. Využití tohoto jazyka přináší celou řadu výhod. Zaprvé, pro velké množství překladačů do LLVM IR je model checker méně závislý na programovacím jazyku, v~němž je napsaný ověřovaný software. Dále, před vlastní model checking lze zařadit již napsané průchody, které nástroji poskytnou užitečné informace nebo zrychlí model checking samotný.

\subsubsection{Vztah k této práci}
Z uvedených důvodů budeme i~v~této práci jako vstupní jazyk využívat právě LLVM IR. Nicméně protože sémantika tohoto jazyka není definovaná formálně a~v~oblasti model checkingu se obvykle pracuje s~přechodovými systémy (jako jsou Kripkeho struktury~\cite{CLARKE}), v~této práci bude výhodné pracovat s~jazykem popisujícím přechodový systém.


\section{Posix threads}
Jazyk LLVM IR sám neposkytuje podporu pro explicitní paralelismus. Té je možné docílit pouze použitím specializovaných knihoven. Knihovna Posix threads (zkráceně pthreads) je standardizovanou knihovnou s rozhraním pro jazyk C, která obsahuje funkce pro manipulaci s vlákny.

\subsection{pthread_create()}
Nejzajímavější funkcí z této knihovny je \texttt{pthread\_create}\cite{man-pthread-create} (viz obrázek~\ref{fig:pthread-create}), která spustí funkci, jež dostala jako jeden ze svých argumentů, v nově vytvořeném vlákně.

\begin{figure}[h!]
\begin{lstlisting}[language=C]
int pthread_create ( pthread_t *thread,
                     const pthread_attr_t *attr,
                     void *(*start_routine) (void *),
                     void *arg                        );
\end{lstlisting}
\label{fig:pthread-create}
\caption{Prototyp funkce \texttt{pthread_create}}
\end{figure}

\section{NTS}
Jazyk NTS (Numerical Transition Systems) je jednoduchý jazyk s~formalizovanou sémantikou~\cite{NTSref}, sloužící pro popis numerických přechodových systémů. NTS mohou modelovat libovolný software~\cite{NTSref} a~protože software je obvykle strukturován do menších částí, NTS obsahuje konstrukce pro hierarchickou i~paralelní kompozici systémů. Následuje stručný popis tohoto jazyka, zájemci o preciznější popis mohou nahlédnout do \cite{NTSref}.

\subsection{BasicNts}
Základní jednotkou NTS je BasicNts, což je samostatný přechodový systém, sestávájící z proměnných, řídících stavů a přechodů mezi nimi. Stavy mohou být označeny jako iniciální, finální a chybové. Přechody jsou tvaru $s_i \overset{R}{\rightarrow} s_j$, kde $R$ je přechodové pravidlo, strážící přechod. Přechod může být vykonán pouze v případě, že je přechodové pravidlo naplněno.

\subsection{Přechodová pravidla}
Přechodová pravidla mohou být dvojího druhu: volací pravidlo (například  $(p1',p2') = \texttt{factorize} (x)$) slouží k zavolání jiného BasicNts, předání parametrů volanému a uložení výsledků volání, zatímco formulové pravidlo (například $d' * d' = x$) obsahuje formuli predikátové logiky prvního řádu, jejíž splnění umožňuje přechod do cílového stavu přechodu. 

\subsection{Formule}
Formule mohou být kvantifikované a jsou složeny pomocí logických spojek z atomických propozic a jiných formulí, přičemž za atomické propozice jsou považovány zejména booleovské termy a výsledky porovnání termů, navíc také \texttt{havoc} (viz~\ref{subsec:nts-havoc}). Nutno poznamenat, že ve formuli se mohou vyskytovat i hodnoty proměnných, platné v cílovém stavu. Tyto jsou označené znakem $\prime$. Jak je vidět u předchozího příkladu, je tak možné vytvořit formuli, která požaduje, aby hodnota proměnné $y$ v příštím stavu byla odmocninou hodnoty proměnné $x$ ve stavu současném.

\subsection{Termy}
Termy jsou již na syntaktické úrovni rozděleny na aritmetické a booleovské. Mezi booleovské termy patří booleovské konstanty, booleovské proměnné a jiné termy, pospojované obvyklými logickými operacemi. Obdobně, aritmetické termy jsou reálné a celočíselné konstanty a proměnné, pospojované aritmetickými operacemi z množiny $\{+, -, *, /, \% \}$. Jazyk explicitně vyžaduje, aby všechny subtermy každého termu měly stejný datový typ, jako celý term.

\subsection{Typový systém}
Jazyk NTS je vybaven třemi skalárními datovými typy: Int, Bool, Real. Datový typ \texttt{Int} reprezentuje matematické celé číslo, jeho doménou je tedy množina $\mathbb{Z}$; datový typ \texttt{Real} reprezentuje matematické reálné číslo, tedy jeho doménou je množina $\mathbb{R}$; nakonec typ \texttt{Bool} nabývá pouze hodnoty z množiny $\{ \texttt{true}, \texttt{false} \}$. Jazyk dále podporuje type pole hodnot libovolného skalárního aritmetického typu.

\subsection{Sémantika}
\label{subsec:nts-configuration}
Konfigurací systému se nazývá dvojice $\tuple{q, v}$, kde $q$ je jedním z řídících stavů a $v$ valuace proměnných (tedy funkce, která každé proměnné přiřazuje hodnotu). Přechod z~konfigurace $\tuple{q_1, v_1}$ do konfigurace $\tuple{q_2, v_2}$ je možný, pokud existuje přechodové pravidlo $q_1 \overset{F}{\rightarrow} q_2$ s~následující vlastností: formule vzniklá z~$F$ nahrazením proměnných $p$ hodnotami $v_1(p)$ a~nahrazením proměnných ve tvaru $p^\prime$ hodnotami $v_2(p)$ je tautologií. Formálnější popis je k~dispozici v~\cite{NTSref}.

\subsection{Havoc}
\label{subsec:nts-havoc}
Havoc je speciální atomická propozice, jejíž účelem je zamezit samovolné modifikaci proměnných neuvedených ve formuli přechodového pravidla. Ve své podstatě se jedná o syntaktickou zkratku.
\begin{equation}
\texttt{havoc} \left( v_1, v_2, \ldots, v_k \right) = \bigwedge_{v \in V \setminus \{ v_1, v_2, \ldots, v_k \}} v = v\prime
\end{equation}
Její význam si můžeme ukázat na následujícím příkladu: uvažme přechodový systém s proměnnými $x,y$ typu int, konfiguraci $s_1 = \tuple{q_1, v_1} \land v_1(x) = 0 \land v_1(y) = 3$, konfiguraci $s_2 = \tuple{q_2, v_2} \land v_2(x) = 1 \land v_2(y) = 5$ a přechod $q_1 \overset{F}{\rightarrow} q_2$. Pokud $F \equiv x' = x + 1$, pak je možné s využitím uvedeného pravidla přejít z konfigurace $q_1$ do konfigurace $q_2$, protože formule $1 = 0 + 1$ je tautologií. Tento přechod ale v rozporu s očekáváním modifikuje proměnnou y. Naopak, pokud $F \equiv x' = x + 1 \land \texttt{havoc}(x)$, potom uvedené pravidlo nelze použít pro přechod z $q_1$ do $q_2$. Po dosazení a expandování \texttt{havoc} totiž vznikne formule $1 = 0 + 1 \land 3 = 5$, která je nesplnitelná.

\subsection{Paralelismus}
Jazyk NTS umožňuje paralelní běh libovolného konečného počtu vláken. Ke každému vláknu je přiřazen \textit{vstupní bod} (entry point), což je BasicNts, který je vykonáván v kontextu daného vlákna. Paralelní NTS obsahuje specifikaci, tvořenou seznamem dvojic \texttt{vstupní bod [ počet vláken ]}. Identifikátory vláken jsem vláknům přiřazeny vzestupně od nuly, a to ve stejném pořadí, v jakém jsou zadány ve specifikaci.  Uvážíme-li příklad \ref{fig:nts-instances}, paralelní NTS obsahuje $N+1$ vláken, přičemž vstupním bodem vláken s $\texttt{tid} \in \{ 0, \ldots, N - 1 \}$ je BasicBlock \texttt{worker_nts} a vstupním bodem vlákna s $\texttt{tid} = N$ je BasicBlock \texttt{main_nts}.

\begin{figure}[h!]
\begin{lstlisting}
instances worker_nts[N], main_nts[1];
\end{lstlisting}
\caption{Specifikace paralelně vykonávaných vláken v jazyce NTS}
\label{fig:nts-instances}
\end{figure}

\subsection{Příklad}
Na obrázku~\ref{fig:nts-prodcons} se nachází příklad jednoduchého paralelního systému s jedním producentem a jedním konzumentem, reprezentovanými BasicNts \texttt{producent} a \texttt{consument}. Po deklaraci globálních proměnných \texttt{G} a \texttt{c} je uvedena formule, kterou musí splňovat iniciální konfigurace  (viz~\ref{subsec:nts-configuration}) paralelního systému. Systém bude obsahovat dvě vlákna, přičemž vlákno s $\texttt{tid} = 0$ bude vykonávat kód BasicNts \texttt{producent} a vlákno s \texttt{tid} bude vykonávat kód \texttt{consument}.

BasicNts \texttt{producent} obsahuje lokální proměnnou \texttt{i}, která je přechodem z iniciálního stavu \texttt{si} nastavena na hodnotu $0$ a každým dalším přechodem inkrementována. Přechod $\texttt{sl} \rightarrow \texttt{sl}$ se může uskutečnit pouze v případě, že globální proměnná \texttt{c} je nastavena na  hodnotu \texttt{false}, a sám tuto proměnnou nastaví na \texttt{true}. Naopak, přechod $\texttt{sl} \rightarrow \texttt{sl}$ v \texttt{consument} může být vykonán pouze v případě, že $\texttt{c} = \texttt{true}$. Činnost celého systému je taková, že \texttt{producent} postupně do proměnné \texttt{G} ukládá zvyšující se hodnoty, které \texttt{consument} sčítá.

Mimochodem, již zmíněný přechod $\texttt{sl} \rightarrow \texttt{sh}$ v \texttt{consument} ničí hodnotu uloženou v \texttt{G}, což ale nevadí, protože \texttt{G} není nikdy čtena.

\begin{figure}[h!]
\begin{lstlisting}
G : int;
c : bool;
init G = 0 && l = false;
instances producent[1], consument[1];

producent {
    initial si;
    i : integer;
    si -> sl { i' = 0 && havoc(i)          }
    sl -> sl { c  = false && c' = true  &&
               G' = i     && i' = i + 1 &&
               havoc(c, G, i)              }
}

consument {
	initial si;
	sum, x : integer;
	si -> sl { sum' = 0 && havoc( sum )          }
	sl -> sh { c = true && x' = G && havoc(x, G) }
	sh -> sl { sum' = sum + x && c' = false &&
	           havoc(sum, c)                     }
}

\end{lstlisting}
\caption{Příklad kódu v jazyce NTL}
\label{fig:nts-prodcons}
\end{figure}

\section{Partial Order Reduction}
Partial Order Reduction je technika pro redukci stavového prostoru (paralelních) programů, která využívá komutativity paralelně vykonávaných přechodů. Pokud lze efektivně ověřit, že stav programu po vykonání přechodů $\texttt{t}_1$ a $t_2$ nezávisí na jejich pořadí a ověřovaná vlastnost není citlivá na jednotlivé přechody, není třeba uvažovat některé možné běhy. Technika použitá v této práci vychází z techniky popsané v \cite{CLARKE}.

\subsection{Nezávislost a komutativita přechodů}
Na rozdíl od \cite{CLARKE} nevyžadujeme, aby přechodová pravidla byla (datově) deterministická. Všechny přechody v NTS již jsou kontrolně deterministické. Nezávislost přechodů tedy definujeme mírně odlišně.
\begin{definition}
Binární relace $I$ na přechodech paralelního NTS nazýváme relací nezávislosti, pokud je symetrická, antireflexivní a splňuje následující požadavek:
Pro libovolné přechody $(t_1, t_2) \in I$ a libovolné stavy (konfigurace v NTS) $s_1, s_2, s_3$ takové, že  $s_1 \xrightarrow{t_1} s_2 \xrightarrow{t_2} s_3$ existuje stav $s_2'$ takový, že $s_1 \xrightarrow{t_2} s_2' \xrightarrow{t1} s_3$.
\end{definition}
Pro NTS bez nedeterministických přechodů je tato definice shodná s definicí v \cite{CLARKE}.

\begin{definition}
Přechod $t$ je povolený ve stavu (konfiguraci) $s$ (píšeme $t \in \texttt{enabled}(s)$ právě tehdy, když existuje stav $s'$ tak že $s \xrightarrow{t} s'$
\end{definition}
Je zřejmé, že pokud pro stav $s = \tuple(q, v)$ a přechod $t$ platí $t \in \texttt{enabled}(s)$, pak $t \in \texttt{outgoing}(q)$. Stavy takové, že vybraný $\texttt{ample}(s) = \texttt{enabled}(s)$, označujeme jako plně expandované.

Technika, použitá v \cite{CLARKE}, tedy partial order reduction s využitím dostatečných (ample) množin, spočívá v tom, že pro každý stav (konfiguraci) paralelního systému je spočítána množina přechodů $\texttt{ample}(s) \subseteq \texttt{enabled}(s)$, která má tu vlastnost, že přechody mimo $\texttt{ample}(s)$ nejsou "důležité". Formálněji řečeno je třeba, aby ke každé cestě v úplném explicitním přechodovém grafu paralelního systému existovala (určitým způsobem) ekvivalentní cesta v tomtéž grafu, která nevyužívá žádné přechody mimo \texttt{ample}. Při konstrukci odpovídajícího sekvenčního systému pak není třeba uvažovat přechody mimo \texttt{ample}, což zmenšuje velikost výsledného sekvenčního systému.

\subsection{Nutné podmínky}
Kniha \cite{CLARKE} uvádí několik podmínek, postačují pro zachování korektnosti. Pro připomenutí, ta kniha pracuje pouze s deterministickými přechody. 

\begin{enumerate}
\item[C0] $\texttt{ample}(s) = \emptyset \Rightarrow \texttt{enabled}(s) = \emptyset$
\item[C1] Každá cesta v úplném explicitním přechodovém grafu paralelního systému, začínající ve stavu $s$, má následující vlastnost: pokud přechod $t_2$, který se vyskytuje po cestě, závisí na nějakém přechodu $t_1 \in \texttt{ample}(s)$, pak se před jeho výskytem vyskytuje nějaký přechod $t_1' \in \texttt{ample}(s)$.
\item[C2] Pokud $s$ není plně expandovaný, pak každý přechod z $\texttt{ample}(s)$ je neviditelný \todo{zadefinovat}.
\item[C3] Nesmí existovat cyklus, který obsahuje přechod povolený v některém z jeho stavů a neobsažený v žádném z \texttt{ample} stavů cyklu.
\end{enumerate}


\subsection{Jednoduchá heuristika}
\subsubsection{Nezávislost}
Definice relace nezávislosti umožňuje jistou flexibilitu při výběru vhodné relace. Za nezávislé budeme považovat ty páry přechodů $(t_1, t_2)$, které splňují obě následující podmínky:
\begin{itemize}
\item Přechody $t_1$ a $t_2$ patří ke dvěma různým vláknům.
\item Neexistuje proměnná, sdílená oběma přechody $t_1$ i $t_2$ a modifikovaná alespoň jedním z nich.
\end{itemize}


\subsubsection{Ample sety}
\todo{Popsat pro obyčejnou POR. Navíc funkci A definujeme až u statické POR}
Pro řídící stav $q_0 = \tuple{q_{0,0}, \ldots, q_{0,k-1}}$ spočítáme $A(q_0)$ následujícím způsobem. Pro každé $0 \leq i < k$ zkusíme položit $A(q_0) = \texttt{outgoing}(q_{0,i})$. Pokud zkoušená množina splňuje podmínky C0 až C3, použijeme jí. Pokud žádná z vyzkoušených množin není použitelná, položíme $A(q_0) = \texttt{outgoing}(q_0)$.

Porušení podmínky C1 \label{subsec:c1-violation} znamená, že v úplném explicitním přechodovém grafu existuje posloupnost $s_0 \xrightarrow{\alpha_0} \ldots \xrightarrow{\alpha_{m-1}} s_m \xrightarrow{\beta} s_{m+1}$, $s_j = (q_j, v_j)$ taková, že $\beta \in \texttt{enabled}(s_l)$, $\beta$ je závislý na nějakém přechodu ve zvoleném $\texttt{ample}(s_0)$ a všechny $\alpha_j$ jsou nezávislé na všech přechodech v $\texttt{ample}(s_0)$. Potom, jak uvádí \cite{CLARKE}, mohou nastat dvě situace.

\begin{itemize}
\item Přechod $\beta$ pochází z vlákna $i$ (tedy $\beta \in \texttt{outgoing}(q_{m,i})$).  Protože $\alpha_j$ jsou nezávislé na $\texttt{ample}(s_0)$, musí pocházet z jiného vlákna než $i$, tedy $q_{0,i} = q_{m,i}$. Protože $\beta \not \in \texttt{ample}(s_0)$, tak $\beta \not \in \texttt{enabled}(s_0)$. V tom případě se ale stavy $s_0$ a $s_m$ liší ve valuaci některých globálních proměnných, které jsou používány přechodem $\beta$, a tedy nějaké vlákno s $tid \neq i$ obsahuje přechod, modifikující proměnnou, která je používána přechodem $\beta$.

\item Pokud $\beta \not \in \texttt{outgoing}(q_{m,i})$, tedy přechod $\beta$ pochází z vlákna jiného než $i$, nějaké jiné vlákno než $i$ obsahuje přechod, který je závislý na nějakém přechodu z $\texttt{ample}(s_0)$. 
\end{itemize}

V obou případech tedy musí nějaké jiné vlákno obsahovat přechod, který s nějakým přechodem z $\texttt{ample}(s_0)$ sdílí proměnnou, která je modifikována jedním z nich. To se dá snadno ověřit, pokud si například předem pro každé vlákno množinu proměnných v něm použitých.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Překlad LLVM na NTS}
\section{Omezení LLVM}

\subsection{Pole}
Nepodporuji (zatím). Přidat podporů některých operací nad poli by ale nemusel být problém

\subsection{Pointery}
Překládací nástroj zatím obecně neumí pracovat s ukazateli, zejména nepodporuje pointerovou aritmetiku. Nicméně protože jazyk LLVM pointery hojně využívá, a to zejména pro práci s globálními proměnnými a lokálními zásobníkově alokovanými proměnnými, překládací nástroj umí korektně přeložit několik speciálních případů použití ukazatelů. Mezi ně patří
\begin{itemize}
\item čtení a zápis globálních proměnných pomocí instrukcí \texttt{load} a \texttt{store},
\item čtení a zápis proměnných alokovaných pomocí instrukce \texttt{alloca} a
\item předávání parametrů funkci \texttt{thread\_create}.
\end{itemize}
\paragraph{Ale s proměnnými se pracuje zkrze pointery!}

\subsection{Instrukce}
Také nepodporuji znaménkovou aritmetiku a hromadu instrukcí. Například znaménkové přetečení při add neošetřuji, přestože je to principiálně možné. Vede to k složitým formulím. Pokud ale bude překladová utilita vyvíjená dále, je to jedna z věcí, která by mohla být volitelná (tedy jestli vracet nedefinovaný výsledek nebo přejít do err stavu nebo pokračovat jako nic). S tím souvisí Poison a Undef values.

\subsection{Znaménkovost}
%\subsubsection{Vyjádření v neznaménkové aritmetice}
Jak číselné datové typy v jazyce LLVM IR, tak přidaný BitVector typ v jazyce NTS jsou bezznaménkové. Nicméně některé LLVM instrukce (například ICMP) mohou interpretovat použité proměnné znaménkově. Přestože je principiálně možné vyjádřit sémantiku znaménkových operací pomocí bezznamnékové aritmetiky \todo{ukázat jak na to}, výsledné formule by byly složitější. \todo{zminit semantiku operaci nad BitVector}
\begin{figure}[h!]
\begin{lstlisting}
%b = icmp slt i8 %x, 10
\end{lstlisting}
\end{figure}
Tato instrukce přiřadí do proměnné 'b' hodnotu 1 právě pokud x je znaménkově menší (signed less then, slt) než hodnota 10, tedy právě pokud x bude mít hodnotu v rozsahu -128 až 9. Tento rozsah, vyjádřený v dvojkovém doplňkovém kódu \todo{Někde zmínit, že llvm ir využívá právě dvojkový doplněk}, odpovídá neznaménkovým hodnotám v rozsahu 0 \ldots 9 nebo 128 \ldots 255. 

\begin{figure}[h!]
\begin{lstlisting}
%b = icmp slt i8 %x, %y
\end{lstlisting}
\end{figure}

Pokud jsou ovšem obě hodnoty neznámé, porovnání je obtížnější. Výsledkem operace bude 1, právě pokud bude splněna jedna z následujících podmínek:

\begin{enumerate}
\item Hodnota proměnné x je záporná a hodnota proměnné y je kladná, tedy v unsigned aritmetice x > 127 a y <= 127.
\item Obě proměnné mají shodné znaménko a zároveň x je neznaménkově menší než y.
\end{enumerate}

Jsou i jiné způsoby, jak v neznaménkové aritmetice vyjádřit chování této instrukce, ale nenašel jsem žádný elegantnější nebo jednodušší. Z tohoto důvodu současná verze překládacího nástroje nepodporuje překlad znaménkových operací do aritmetiky neznaménkových bitvektorů.


\section{Rozšíření NTS}

\subsection{Typ BitVector}
Jak můžeme vidět v předchozích částech, typový systém jazyka NTS se od typového systému LLVM IR 
%\ref{subsec:llvm-type-system}
v mnohém liší. Zatímco v LLVM IR mohou stejný datový typ (Integer type, například i8) využívat jak aritmetické instrukce (binary instructions), tak bitové logické instrukce (bitwise binary instructions), jazyk NTS již na úrovni syntaxe podporuje logické operace pouze nad termy typu Bool. Pro překlad LLVM IR do NTS je tedy nezbytné cílový jazyk vhodným způsobem rozšířit. Možností je více:
\begin{enumerate}
\item Rozšířit logcké operace i nad datový typ Int. Jaký by ale byl význam například negace? Totiž, pro různou bitovou šířku dává negace různý výsledek. Budeme-li mít například proměnnou typu Int s hodnotou 5 (binárně 101), pokud se na ní budeme dívat jako na 4 bitové číslo (tedy 0101), dostaneme po negaci 10 (1010), pokud se na ní budeme dívat jako na 3 bitové číslo, dostaneme po negaci hodnotu 2 (binárně 010). 

\item Zavést speciální operátory, které budou v sobě obsahovat informaci o uvažované bitové šířce.

\item Zavést datový typ BitVector<k>, který je vlastně k-ticí typu Bool. Na něm můžeme dělat logické operace bitově a aritmetické operace jako na binárně reprezentovaném čísle. 
\end{enumerate}

Volíme třetí způsob.

V syntaxi původního nts je rozlišováno mezi aritmetickým a booleovském literálem. Chtěli bychom nějak zapisovat bitvectorové hodnoty. Ve hře jsou dvě možnosti:

\begin{enumerate}

\item Pro zápis konstant typu BitVector<k> bychom mohli používat speciální syntaxi. Například zápis 32x"01abcd42" může představovat konstantu typu BitVector<32>, zapsanou v hexadecimálním tvaru. Toto řešení je navíc vhodné pro zápis speciálních konstant (jako $2^{31}$) v lidsky čitelném tvaru. 

\item Aritmetické literály mohou mít schopnost být Int-em nebo BitVector<k>-em podle potřeby (polymorfismus?).

\end{enumerate}

Použita byla druhá možnost (také si jí tu podrobněji popíšeme). V případě potřeby můžeme do jazyka přidat i tu první, ale už ne kvůli potřebě rozlišovat mezi datovými typy, ale kvůli užitečnosti zapisovat některé konstanty hezky.

Syntaxi jazyka zjednodušíme tak, že definujeme jeden neterminál <term> místo dvou neterminálů <arith-term> a <bool-term>. S každým termem bude ale spojená sémantická informace, kterou je jeho datový typ. Definujeme následující skalární datové typy:

\begin{enumerate}
\item Int
\item BitVector<k>, $\forall k \in \mathbb{N^+}$
\item Real
\end{enumerate}

Původní datový typ Bool chápeme jako zkratku za typ BitVector<1>

\begin{grammar}
<literal> ::= <id> | tid | <numeral> | <decimal>

<aop> = `+'  | `-' | `*' | `/' |  `\%'

<bop> = `&' | `|' | `->' | `<->'

<op> = <aop> | <bop>

<term> ::= <literal> | <term> <aop> <term> | <term> <bop> <term> | `(' <term> `)'
\end{grammar}
%TODO mozna by v gramatice melo byt:
% <uop> = `-' | "not"
% <term> ::= .... <uop> <term>
% to ale neni 100% podporovane. Nebo ano?
%TODO gramatika muze byt v plovoucim prostredi

\subsection{Typovací pravidla}
Abychom zajistili, že syntakticky stejný výraz může být typu BitVector nebo Int, definujeme typovou třídu Integral se členy BitVector<k> a Int. Typ výrazu je definován rekurzivně

\begin{enumerate}
\item[TR1] Numerická konstanta <numeral> je libovolného typu 'a' z třídy Integral.
\item[TR2] <decimal> je typu Real
\item[TR3] tid je libovolného typu 'a' z třídy Integral
\item[TR4] <id> je stejného typu, jako odpovídající proměnná
\end{enumerate}

%BTW BitVector můžeme chápat jako typový konstruktor
%TODO neni korektni delat logicke operace nad dvemi nespecifikovanymi integraly.
%V pravidlech to zachytim, ale v programu to zatim neni.

Mějme termy\\
a1 :: Integral a => a\\
a2 :: Integral b => b\\
b1 :: BitVector<k1> \\
b2 :: BitVector<k2>\\
i1 :: Int\\
i2 :: Int\\

Potom:
a1 <aop> a2 :: Integral a => a
a1 <op>  b1 :: Bitvector<k1>
a1 <aop> i1 :: Int
b1 <op>  b2 :: BitVector<max{k1,k2}>
i1 <aop> i2 :: Int

Tato pravidla platí i komutativně. Co se do nich nevejde, není typově správný výraz.

Tedy přidáváme datový typ BitVector, typové třídy a implicitní typová konverze.

Btw můžeme využívat anotace. Zatím je využíváme jenom trochu, ale dají se o nich vkládat
i nějaké informace z LLVM nebo další postřehy.

\section{Vlastni preklad}

\subsection{Funkce}
Jak jazyk NTS, tak LLVM IR podporují určitou formu hierarchického členění programu na podprogramy. Zatímco u LLVM IR je základní jednotkou tohoto členění funkce, v případě jazyka NTS jde o BasicNts, který reprezentuje jednoduchý přechodový systém. Jak funkce, tak BasicNts mohou mít libovolný počet (vstupních) parametrů zvoleného typu, ašak zatímco funkce může vracet nejvýše jednu hodnotu, BasicNts může definovat libovolný počet výstupních parametrů. Funkce i BasicNts navíc mohou definovat lokální proměnné. Vzhledem k těmto podobnostem je celkem přirozené překládat funkce z LLVM IR na BasicNts.

\subsection{BasicBlocky}
Každá funkce se skládá z BasicBlocků. Protože žádná instrukce uvnitř základního blocku nemění tok řízení a po jejím vykonání je vykonávána instrukce následující, můžeme každý základní blok s N vnitřními instrukcemi přeložit jako N nových řídících stavů, kde n-tý stav odpovídá stavu programu po vykonání n instrukcí. Sémantika jednotlivých vnitřních instrukcí bude poté zachycena v přechodových pravidlech mezi jednotlivými stavy.

\paragraph{Terminující instrukce}
Nicméně poslední instrukce v základním bloku může změnit tok řízení, například ukončit vykonávání funkce nebo skočit na začátek jiného základního bloku. Třída takovýchto instrukcí se nazývá "terminační instrukce", protože tyto instrukce ukončují základní blok. Odpovídající přechody tedy nemusí vést do nového stavu, ale do již existujícího stavu jiného základního bloku.

\todo{Zmínit SSA}
V jazyce LLVM IR existuje instruce Phi, reprezentující $\Phi$ uzel \todo{známe z teorie překladačů?} v SSA jazyce. Tato instrukce se nachází pouze na začátku základního bloku a jeí výsledek je závislý na předchozím dokončeném základním bloku. Z tohoto důvodu jsou při překladu funkce základní bloky očíslovány a každá terminující instrukce ukládá číslo svého základního bloku do speciální proměnné. Samotná phi instrukce však v době psaní tohoto textu není v překládacím nástroji implementována.



%\subsubsection{Znaménkové datové typy v NTS}

\subsection{Model paralelismu}
\label{subsec:paralelism}
\todo{Možná, že popis paralelních modelů LLVM a NTS nepatří do této sekce. Někde to ale vysvětlit musím.}

Jazyky LLVM IR a NTS implementují paralelismus velice odlišně. Během návrhu překladu jsme preferovali pokrytí možných použití pthreads v LLVM před jednoduchostí výsledného NTS.

\subsubsection{LLVM, pthreads}
Volání této funkce se může ve zdrojovém programu vyskytnout kdekoliv, a na umístění a četnost těchto výskytů neklademe žádná omezení. Omezujeme ale možnosti použití této funkce, a to následujícím způsobem:

\begin{enumerate}
\item První argument musí být ukazatel na globální proměnnou či lokální proměnnou volající funkce.
\item Argument parametru start\_routine musí být přímo funkce, nikoliv jiný funkční ukazatel.
\item Všechny ostatní argumenty funkce \texttt{pthread\_create} musí být null.
\item Návratová hodnota funkce \texttt{pthread\_create} nesmí být použita.
\item Funkce, předaná jako argument parametru start\_routine, nesmí používat svůj parametr.
\item Návratová hodnota této funkce musí být vždy null.
\end{enumerate}


\subsubsection{NTS}
Jazyk NTS řeší paralelismus odlišným způsobem. 

\subsubsection{Překlad}
V případě paralelního LLVM překládací program vygeneruje NTS, jež vytváří 1 hlavní vlákno a N vláken pracovních. Každé pracovní vlákno má přiřazeno stav a v každém čase se nachází buď ve stavu nečinném, nebo ve stavu činném. Protože na začátku běhu programu v jazyce LLVM IR je spuštěno pouze jedno vlákno, zatímco v přechodovém systému NTS jsou spuštěna všechna vlákna, chceme, aby běžící pracovní vlákna neměla žádný \textit{efekt}. Tedy pracovní vlákno bude ve výchozím stavu v režimu nečinném. Veškerá volání funkcí \texttt{pthread\_create} nahradíme kódem, který způsobí, že se nějaké nečinné pracovní vlákno stane činným a začne vykonávat kód odpovídající funkce. Po ukončení běhu této funkce vlákno opět přejde do stavu nečinnosti a je tak možné ho znovu využít.

\todo{Vložit někam výsledný NTS kód}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Statická Partial Order redukce}

\section{Obecně k sekvencializaci}
V rámci zachování jednoduchosti v této části textu používáme o něco jednodušší definice než v \cite{NTSref}, zejména vypouštíme definici valuace proměnných.

\begin{definition}
Řídící stav plochého paralelního NTS s k vlákny je k-tice $q = \tuple{q_0, \ldots, q_{k-1}}$, kde $q_i$ je řídící stav BasicNts, který je vykonáván ve vlákně s $\texttt{tid} = i$.
\end{definition}
%V souladu s tím, co bylo řečeno v úvodu \todo{říci to v úvodu}, řídící stavy sekvencializovaného NTS nenesou informaci o valuaci datových proměnných. \todo{Pokud ano, tak pouze pro optimalizaci - v budoucnu.}
S každým řídícím stavem $q$ paralelního NTS je spojena množina přechodů $\texttt{Outgoing}(q)$, vedoucích z tohoto stavu.
\begin{equation}
\texttt{outgoing}(q) = \texttt{outgoing}(q_0) \cup \ldots \cup \texttt{outgoing}(q_{k-1})
\end{equation}

\begin{definition}
Stav $s$ paralelního přechodového systému je dvojice $s = \tuple{q, v}$, kde $v$ je řídící stav daného systému a $v$ značí valuaci (globálních i všech lokálních) proměnných.
\end{definition}
Referenční manuál označujuje právě definovaný stav jako "konfiguraci".

\todo{Formálněji, odkaz do manuálu}
\begin{definition}
Pro libovolný přechod $t$ a stavy $s_1, s_2$ paralelního systému, zápisem $s_1 \xrightarrow{t} s_2$ rozumíme, že je možné dostat se ze stavu $s_1$ do stavu $s_2$ pomocí přechodu $t$. Zápisem
\begin{equation*}
s_1 \xrightarrow{t_1} s_2 \xrightarrow{t_2} \ldots \xrightarrow{t_{m-1}} s_m
\end{equation*}
zkracujeme konjunkci
\begin{equation*}
s_1 \xrightarrow{t_1} s_2 \land \ldots \land s_{m-1} \xrightarrow{t_{m-1}} s_m
\end{equation*}
\end{definition}

\section{Použití POR bez znalosti dat - statické}
Navazuje na POR vysvětlenou dříve. Jak tedy POR upravit tak, aby fungovalo staticky.


Uvedené podmínky se vztahují k explicitnímu CFG, zatímco náš nástroj generuje symbolický CFG a o proměnných si mnoho informací neudržuje. Protože $\texttt{ample}(s) \subseteq \texttt{enabled}(s)$, nemůžeme generovat ample sety přímo: museli bychom totiž rozhodnout, zda je nějaký z přechodů v daném stavu povolený. Náš nástroj namísto toho pro \textit{řídící} stav (tedy nikoliv konfiguraci) $q$ paralelního systému spočítá množinu $A(q) \subseteq \texttt{outgoing}(q)$ tak, že pro libovolný stav (konfiguraci) $s = (q, v)$ můžeme položit $\texttt{ample}(s) = A(q) \cap \texttt{enabled}(s)$.

\paragraph{Problém s C0}
Pokud zvolíme A neprázdné tak, že je dosažitelný stav, kdy žádný přechod z A nebude proveditelný, ale nějaký přechod mimo A ano, pak dojde k porušení C0. Toto je ale problém pouze pro obecné NTS, protože přechody překládané z LLVM IR jsou vždy proveditelné. \todo{To není tak docela pravda - viz například podmíněné skoky. Ale dost možná je pravda, že vždycky bude alespoň jeden přechod z daného stavu uskutečnitelný.}



\begin{definition}
Pro libovolný přechod $t$ (tedy i přechod s volacím pravidlem) zápisem $W(t)$ rozumíme množinu proměnných, které může přechod $t$ změnit, a zápisem $R(t)$ množinu proměnných, které přechod $t$ čte. Pro libovolné vlákno $P$ zápisem $W(P)$ rozumíme množinu takových proměnných, že pro každou $v \in W(P)$ existuje přechod $t$ vlákna $P$ t.ž. $v \in W(t)$. Obdobně definujeme i $R(P)$.
\end{definition}

\section{Problémy}

\subsection{Problém velkého vlákna}
Ukazuje se, že pro zvolený model paralelismu \ref{subsec:paralelism} uvedená heuristika není příliš efektivní. Pro velkou množinu programů \todo{všechny, které lze vyjádřit v modelu "vytvoř vlákna na začátku", todo taky nekde popsat dalsi mozne modely} totiž napočítané množiny $W(P_i)$ a $R(P_i)$ obsahují mnoho proměnných, které ve skutečnosti vlákno $i$ nepoužívá.


\subsubsection{Problémová situace}
Uvažme například příklad \todo{reference}. Hlavní funkce vytvoří dvě vlákna, která používají vzájemně disjunktní množiny globálních proměnných. Po přeložení do jazyka NTS (se zvoleným modelem paralelismu) výsledné NTS obsahuje vygenerované BasicNts "__thread_pool_routine" \todo{Program to pojmenovava '__thread_poll_routine' - prijde opravit}, které obsahuje přechody, volající přeložené funkce @p1 a @p2.
\begin{figure}[h!]
\begin{lstlisting}
@G1 = global i32 16;
@G2 = global i32 0;

define i8* @p1 ( i8* %x ) {
	... ; some local calculations
t1:	store i32 42, i32* @G1;
	ret i8* null;
}

define i8* @p2 ( i8* ) {
	... ; some more local calculations
t2:	store i32 14, i32* @G2;
	ret i8* null;
}

define void @main() {
	call i32 @pthread_create ( ..., @p1, ... );
	call i32 @pthread_create ( ..., @p2, ... );
	ret void;
}
\end{lstlisting}
\caption{Vlákna, využívající odlišnou sadu proměnných. Zjednodušeno.}
\end{figure}

\begin{figure}
\begin{lstlisting}
instances __thread_pool_routine[2], main[1];
...
__thread_pool_routine {
	initial	si;
	si  -> sr1 { ...  }
	sr1 -> ss  { p1() }
	ss  -> si  { ...  }
	si  -> sr2 { ...  }
	sr2 -> ss  { p2() }
	ss  -> si  { ...  }
}
\end{lstlisting}
\caption{Přechodový systém pracovního vlákna}
\end{figure}

Po zploštění tedy thread\_pool\_routine obsahuje přechody, které odpovídají původním funkcím p1 a p2. Protože tento BasicNts je vykonáván v každém pracovním vlákně, v každém pracovním vlákně jsou také obsaženy všechny přechody přeložených funkcí p1 a p2. Potom napočítané množiny $W(P_0) = W(P_1) \supseteq \{ G1, G2\}$. V situaci, kdy některé z vláken zapisuje do $G1$ (viz t1), potom nedojde k použití přechodu odpovídajícího t1 jako jednoprovkového ample setu, přestože žádný jiný přechod není na t1 závislý. 

\subsubsection{Možné řešení}
Pro zvolený model paralelismu se rozložení programu na vlákna zdá být příliš hrubým, protože mnohá vlákna budou mít totožné řízení (BasicNts, viz předchozí příklad). Rozložme tedy program jemněji na jednotky, kterým budeme říkat "úlohy".

\begin{definition}
Pro plochý (i paralelní) přechodový systém N, množina úloh $\texttt{Tasks}(N)$ je množina taková, že libovolný řídící stav nějakého BasicNts z N leží v právě jedné úloze $T \in \texttt{Tasks}(N)$.
\end{definition}

Přechodové systémy, vzniklé překladem pomocí našeho nástroje z LLVM IR a následným zploštěním, obsahují právě dva použité BasicNts: první z nich odpovídá funkci \texttt{main} původního programu, druhý pak kódu vykonávaným vláknem z thread poolu. Pro účely této práce můžeme rozdělit jejich stavy do úloh následujícím způsobem.

\begin{enumerate}
\item Máme právě jednu hlavní úlohu $T_{\texttt{main}}$, právě jednu nečinnou úlohu $T_{\texttt{idle}}$ a jednu úlohu $T_{f_i}$ pro každou funkci $f_i$, která je někde v původním LLVM IR programu předávána jako parametr funkce \texttt{pthread\_create}.
\item Každý stav $s$ hlavního BasicNts (tj. toho, který vznikl překladem funkce main) leží v $T_{\texttt{main}}$.
\item Všechny stavy, odpovídající stavům nezploštělého \texttt{\_\_thread\_pool\_routine}, leží v $T_{\texttt{idle}}$.
\item Všechny ostatní řídící stavy jsou řídícími stavy zploštělého \texttt{\_\_thread\_pool\_routine}, do kterého se dostaly během fáze zplošťování. Každý z těchto stavů přiřadíme úloze $T_{f_i}$ takové, že daný stav pochází z funkce $f_i$.
\end{enumerate}

Koncept úloh přirozeně rozšiřujeme i na přechody:
\begin{definition}
Přechod $t$ náleží úloze $T$ (zapisujeme $t \in \texttt{trans}(T)$) právě tehdy, když zdrojový řídící stav $s$ přechodu $t$ ($s = \texttt{from}(t)$) náleží úloze $T$ ($s \in T$).
\end{definition}
Protože každý přechod má jeden zdrojový řídící stav, každý přechod náleží právě jedné úloze. Tímto způsobem můžeme o každé úloze říci, jaké globální proměnné používá.

\begin{definition}
Zápis $W(T)$ rozšiřujeme na úlohy následujícím způsobem:
\begin{equation*}
v \in R(T) \Leftrightarrow \exists t, t \in \texttt{trans}(T) \land v \in R(t)
\end{equation*}
\begin{equation*}
v \in W(T) \Leftrightarrow \exists t, t \in \texttt{trans}(T) \land v \in W(t)
\end{equation*}
\end{definition}
Tedy úloha $T$ čte globální proměnnou $v$ právě tehdy, pokud existuje přechod $t$, který čte $v$ a patří $T$. Podobně, $T$ mění $v$ právě pokud nějaký přechod $t$ patřící $T$ mění $v$.
Dále, v každém řídícím stavu paralelního systému můžeme některé úlohy označit jako \textit{aktivní}.
\begin{definition}
Pro řídící stav $q = \tuple{q_0, \ldots, q_{k-1}}$ paralelního systému definujeme množinu $\texttt{active}(q) = \{ T \suchthat \exists i, 0 \leq i < k \land q_i \in T \}$
\end{definition}

Jednou ze situací, která se hojně vyskytuje, je "přepnutí úlohy". V případě přechodových systémů, vzniklých překladem z LLVM, například často dochází k přepnutí $T_\texttt{idle}$ na nějakou $T_{f_i}$. 

\newcommand{\switchto}{\rightarrow}
\newcommand{\canswitchto}{\dashrightarrow}

\begin{definition}
Definujeme antireflexivní binární relaci nad úlohami $\switchto$ tak, že $T_1 \switchto T_2$ právě tehdy, když $T_1 \neq T_2$ a existují řídící stavy paralelního systému $q_1, q_2$, valuace $v_1, v_2$ a přechod $t$ takové, že stav (konfigurace) $\tuple{q_1, v_1}$ je v paralelním systému dosažitelný, $T_1 \in \texttt{active}(q_1) \land T_2 \in \texttt{active}(q_2)$ a $\tuple{q_1, v_1} \xrightarrow{t} \tuple{q_2, v_2}$.
\end{definition}

Protože rozhodnout dosažitelnost nějakého stavu není snadné, budeme často pracovat volnější s relací "$T_1$ se může přepnout na $T_2$".

\begin{definition}
Binární relace nad úlohami $\canswitchto$ je relací možného přepnutí, pokud je antireflexivní a pro libovolné dvě úlohy $T_1, T_2$ takové, že $T_1 \switchto T_2$, platí $T_1 \canswitchto T_2$.
\end{definition}

Nyní se můžeme vrátit k úvahám ze sekce \ref{subsec:c1-violation}. Přechod $\beta$ jistě leží v nějaké úloze $T_{\beta}$. Pokud přechod $T_{\beta} \not \in \texttt{active}(s_0)$, $T_{\beta}$ musela být aktivována během sekvence přechodů $\alpha_j$. Musí tedy existovat nějaká úloha $T$, kterou je možné po několika přepnutích přepnout až na $T_{\beta}$, zejména pak dvojice $\tuple{T, T_{\beta}}$ musí ležet v tranzitivním uzávěru relace $\canswitchto$.


\todo{Jak může úloha způsobit přepnutí jiné úlohy na ještě jinou}

%Protože každé pracovní vlákno (kromě vlastního) může potenciálně vykonávat libovolnou úlohu, tak téměř každé vlákno může použít téměř každou proměnnou. Redukce by se zredukovala na pouhý test "používám globální proměnné"?
%Tedy je potřeba mít rozdělené stavy / přechody do úloh. O každé úloze spočítáme, jaké globální proměnné používá, a také, jaké jiné úlohy může aktivovat. Potom, pokud budeme znát řídící stav každého vlákna, můžeme zjistit, jaké úlohy běží a tedy i jaké globální proměnné jsou důležité.

\subsection{Problém velkého pole}
V případě, že bychom měli pole takové, že by na každou jeho pozici přistupoval nejvýše jeden proces,
a procesů bychom měli mnoho, vyplatilo by se sledovat jeho jednotlivé buňky zvlášť. To ale neděláme. Btw jedno takové pole máme.

\subsection{Problém závislosti na datech}
Zda může nějaké vlákno běžet, závisí na datech. My se ale o data moc nestaráme (TODO: tohle je třeba ujasnit na začátku). Tedy nemůžeme vědět, že na začátku poběží jenom hlavní vlákno. Tedy zeserializovaný systém bude obsahovat běhy, jejihž podmínka cesty bude nesplnitelná. Obecně tohle řešit snadno nelze, ale pokud se omezíme na zjištění informace, zda nějaké vlákno z thread poolu může začít vykonávat nějakou úlohu, stačí nám sledovat pár zvolených proměnných. Na to máme dvě možnosti:

a) Analyzovat vykonávané přechody, zda modifikují naše vybrané proměnné. Předpokládáme, že většina formulí bude mít hezký tvar, a že tedy nemusíme vědět všechno na to, abychom některé mohli rovnou označit za nesplnitelné a o jiných prohlásit, že modifikují námi vybranou proměnnou jednoduchým způsobem.

b) Umět rozpoznat původně existující struktury i v přeloženém a zplacatělém přechodovém systému. Tedy musíme vědět, co jsou pracovní vlákna, co dělá \_\_thread\_create (a jak jí poznám) a další věci.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Implementace libNTS}
\section{Motivace}
Proc jsem nepouzil stavajici knihovny.
\section{Omezení}
Zatím nepodporuji složitější operace s poli. Také nechápu, jak pracovat s parametry (par).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Experimenty}
\section{Použití implementovaných nástrojů}
\todo{Tuto část textu bych rád viděl i v příslušných README.md}
\subsection{Získání}
\subsection{Kompilace}
\subsection{Instalace?}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Závěr}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Nepřiřazeno}
\section{Inlining}
Jo teda nepodporuju rekurzi, a proto si můžu dovolit to, co dělám v inlineru - prostě tak dlouho zainlinovávám jednotlivé BasicNts, až mi nezůstané žádné volání.

\section{Možná budoucí rozšíření}
\todo{Petr psal autorům NTS, a pokud si dobře vzpomínám, jeden z nich projevil přání, abychom mohli překládat llvm do stávající podmnožiny NTS - tedy do intů. Celé LLVM tak nepůjde, ale jistá podmnožina ano. Každopádně zatím se na tom nepracuje.}

\subsection{Znaménkové datové typy v NTS}


\tableofcontents

\printbibliography

\end{document}